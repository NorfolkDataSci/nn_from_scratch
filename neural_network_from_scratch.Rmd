---
title: "NN From Scratch"
output: html_notebook
---

**Get data set
```{r echo=TRUE}
data("iris")

iris_sub <- iris[ which(iris$Species == "setosa" | iris$Species == "virginica"), ]

iris_sub <- iris_sub[sample(nrow(iris_sub)),]

smp_size <- floor(0.75 * nrow(iris_sub))
set.seed(123)
train_ind <- sample(seq_len(nrow(iris_sub)), size = smp_size)

train <- iris_sub[train_ind, ]
test <- iris_sub[-train_ind, ]

df_x  <- train[,(1:4)]

df_y <- as.data.frame(train[,5])

df_y <- as.data.frame(df_y$`train[, 5]` == "setosa")
```

**Hyperparameters
```{r}
learning_rate <- 0.5
epochs <- 9
```

**Various activation functions
```{r}
sigmoid <- function (z) {
  return(1 / (1 + exp(-1*z)))
}

relu <- function (z) {
  return(max(0,z))
}

tanh <- function (z) {
  return((exp(z) - exp(-1*z)) / (exp(z) + exp(-1*z)))
}
```

**derivatives
```{r}
sigmoid_deriv <- function(z) {
  return(exp(z) / ((exp(z) + 1)^2))
}

relu_deriv <- function(z) {
  if (z < 0) {
    return(0)
  } else {
    return(1)
  }
}

tanh_deriv <- function(z) {
  return(4 * exp(2 * z) / (exp(4 * z) + 2 * exp(2 * z) + 1))
}

loss_deriv <- function(y_hat, y) {
  return(y_hat - y)
}
```

**Regularization functions
```{r}
dropout <- function (layer_output) {
  z <- rbinom(nrow(layer_output), 1, 0.5)
  return(z * layer_output)
}
```

**The two parts of each node
```{r}
# IN: 1x1, 1x1, 1x1
# OUT: 1x1
node <- function (w, x) {
  z <- w * x
  # IN: 1x1
  # OUT: 1x1
  return(z)
}

# IN: 1x1
# OUT: 1x1
node_activation <- function(z, FUN){
  y <- FUN(z)
  return(y)
}
```

**Layer of a NN
```{r}
# IN: 1x4, 1x1, 1x1
# OUT: 1x1
layer_node <- function (vals, FUN = sigmoid, weight_df, bias) {
  res <- c()
  for(i in 1:ncol(vals)) {
    # IN: 1x1, 1x1, 1x1
    # OUT: 1x1
    res[i] <- node(weight_df, vals[,i])
  }
  
  return(node_activation((sum(res) + bias), FUN))
}

# IN: 1x4, 5x1, 1x1
# OUT: 5x1
layer <- function (df, nodes, FUN = sigmoid, weight_df, bias) {
  res <- matrix(ncol=1, nrow=nodes)
  for(i in 1:nodes){
    # IN: 1x4, 1x1, 1x1
    # OUT: 1x1
    res[i,] <- layer_node(df, FUN, weight_df[i,], bias)
  }
  return(data.frame(res))
}
```

**Loss and Cost
```{r}
loss <- function(y_hat, y){
  res <- 1 / 2 * (y_hat - y)^2
  
  return(res)
}

cost <- function(l){
  l <- as.data.frame(l)
  res <- 1 / nrow(l) * colSums(l)
  return(res)
}
```

**Random Initialization
```{r}
rand_init <- function(K) {
  res <- data.frame(abs(rnorm(K)))
  return(res)
}
```

**Need to implement backprop
```{r}

```

**Update weights function
```{r}
update <- function(weights, change, learn_rate) {
  weights <- learn_rate*(weights - change)
}
```

**Implementation of a simple forward prop, with all observations and 5 epochs
```{r}
return <- as.data.frame(matrix(ncol=5, nrow=nrow(df_x)))

layer_0_weights <- rand_init(5)
layer_1_weights <- rand_init(10)
layer_2_weights <- rand_init(10)
layer_3_weights <- rand_init(1)
bias <- 0.05
for (j in 1:epochs) {
  for (i in 1:nrow(df_x)) {
    # Forward Prop
    
    # IN: 1x4, 5x1, 1x1
    # OUT: 5x1
    layer_0 <- layer(df_x[i,], 5, sigmoid, layer_0_weights, bias)
    # IN: 5x1
    # OUT: 1x5
    layer_0_t <- t(layer_0)
    # IN: 1x5, 10x1, 1x1
    # OUT: 10x1
    layer_1 <- layer(layer_0_t, 10, tanh, layer_1_weights, bias)
    # IN: 10x1
    # OUT: 10x1
    layer_1_reg <- dropout(layer_1)
    # IN: 10x1
    # OUT: 1x10
    layer_1_reg_t <- t(layer_1_reg)
    # IN: 1x1, 10x1, 1x1
    # OUT: 10x1
    layer_2 <- layer(layer_1_reg_t, 10, tanh, layer_2_weights, bias)
    # IN: 10x1
    # OUT: 10x1
    layer_2_reg <- dropout(layer_2)
    # IN: 10x1
    # OUT: 1x10
    layer_2_reg_t <- t(layer_2_reg)
    # IN: 10x1, 1x1, 1x1
    # OUT: 1x1
    layer_3 <- layer(layer_2_reg_t, 1, sigmoid, layer_3_weights, bias)
    
    L <- loss(layer_3, df_y[i,])
    
    # Backward Prop
    
    l_b_prop <- loss_deriv(layer_3, df_y[i,])
    
    layer_3_b_prop <- layer(layer_2_reg_t, 1, sigmoid_deriv, layer_3_weights, bias)
    
    layer_2_b_prop <- layer(layer_1_reg_t, 10, tanh_deriv, layer_2_weights, bias)
    
    layer_1_b_prop <- layer(layer_0_t, 10, tanh_deriv, layer_1_weights, bias)
    
    layer_0_b_prop <- layer(df_x[i,], 5, sigmoid_deriv, layer_0_weights, bias)
    
    return[i,j] <- L
  }
  
  c <- cost(return[,j])
  
  layer_0_weights <- update(layer_0_weights, c, learning_rate)
  layer_1_weights <- update(layer_1_weights, c, learning_rate)
  layer_2_weights <- update(layer_2_weights, c, learning_rate)
  layer_3_weights <- update(layer_3_weights, c, learning_rate)
}
```